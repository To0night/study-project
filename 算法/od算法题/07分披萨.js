/* 
"吃货"和"馋嘴"两人到披萨店点了一份铁盘（圆形）披萨，并嘱咐店员将披萨按放射状切成大小相同的偶数个小块。
但是粗心的服务员将披萨切成了每块大小都完全不同奇数块，且肉眼能分辨出大小。
由于两人都想吃到最多的披萨，他们商量了一个他们认为公平的分法：从"吃货"开始，轮流取披萨。除了第一块披萨可以任意选取外，其他都必须从缺口开始选。
他俩选披萨的思路不同。"馋嘴"每次都会选最大块的披萨，而且"吃货"知道"馋嘴"的想法。
已知披萨小块的数量以及每块的大小，求"吃货"能分得的最大的披萨大小的总和。

输入描述
第 1 行为一个正整数奇数 N，表示披萨小块数量。

3 ≤ N < 500
接下来的第 2 行到第 N + 1 行（共 N 行），每行为一个正整数，表示第 i 块披萨的大小

1 ≤ i ≤ N
披萨小块从某一块开始，按照一个方向次序顺序编号为 1 ~ N

每块披萨的大小范围为 [1, 2147483647]
输出描述
"吃货"能分得到的最大的披萨大小的总和。

输入
5
8
2
10
5
7
输出
19

此例子中，有 5 块披萨。每块大小依次为 8、2、10、5、7。
按照如下顺序拿披萨，可以使"吃货"拿到最多披萨：
"吃货" 拿大小为 10 的披萨
"馋嘴" 拿大小为 5 的披萨
"吃货" 拿大小为 7 的披萨
"馋嘴" 拿大小为 8 的披萨
"吃货" 拿大小为 2 的披萨
至此，披萨瓜分完毕，"吃货"拿到的披萨总大小为 10 + 7 + 2 = 19
可能存在多种拿法，以上只是其中一种。
*/
const readline = require('readline');

// 创建 readline 接口
const rl = readline.createInterface({
	input: process.stdin,
	output: process.stdout,
});

let lines = []; // 用于存储输入行的数组
let n; // 披萨的数量
let a; // 每块披萨的美味值
let dp; // 记忆化数组，用于存储已计算过的状态

// 处理输入
rl.on('line', (line) => {
	lines.push(line);
}).on('close', () => {
	// 处理 lines 中的数据
	[n, ...a] = lines.map(Number); // 第一行是披萨的数量，接下来的行是每块披萨的美味值
	a = a.slice(0, n); // 截取前 n 个数字作为美味值数组
	dp = Array.from({ length: n }, () => Array(n).fill(-1)); // 初始化记忆化数组
	let ans = 0; // 初始化最大美味值为 0
	for (let i = 0; i < n; i++) {
		ans = Math.max(ans, allocation((i + 1) % n, (i + n - 1) % n) + a[i]);
	}
	console.log(ans); // 输出最多能吃到的披萨的美味值总和
});

// 计算最大美味值的函数
function allocation(L, R) {
	if (dp[L][R] !== -1) {
		return dp[L][R]; // 如果已计算过，直接返回结果
	}
	if (a[L] > a[R]) {
		L = (L + 1) % n; // 左边披萨更美味，吃掉左边的
	} else {
		R = (R + n - 1) % n; // 右边披萨更美味，吃掉右边的
	}
	if (L == R) {
		dp[L][R] = a[L]; // 只剩一块披萨时，返回其美味值
	} else {
		dp[L][R] = Math.max(a[L] + allocation((L + 1) % n, R), a[R] + allocation(L, (R + n - 1) % n));
	}
	return dp[L][R]; // 返回当前状态下的最大美味值
}
